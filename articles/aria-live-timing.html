<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Understanding aria-live timing: a two-layer model - Max Design</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="../assets/css/styles.css" rel="stylesheet">
  <meta name="description" content="Did you know that there are two completely separate systems that determine when live regions are spoken">
  <meta name="keywords" content="training, accessibility, maxdesign, max design, web design, web development, css, web-standards">
  <link rel="apple-touch-icon-precomposed" href="https://maxdesign.com.au/apple-touch-icon-precomposed.png">
  <link rel="apple-touch-icon-precomposed" sizes="72x72" href="https://maxdesign.com.au/apple-touch-icon-72x72-precomposed.png">
  <link rel="apple-touch-icon-precomposed" sizes="114x114" href="https://maxdesign.com.au/apple-touch-icon-114x114-precomposed.png">
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://maxdesign.com.au/apple-touch-icon-144x144-precomposed.png">
  <link rel="shortcut icon" href="https://maxdesign.com.au/favicon.ico">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,400;0,500;0,700;1,400;1,500;1,700&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab&display=swap" rel="stylesheet">
  <link rel="alternate" type="application/rss+xml" href="https://www.maxdesign.com.au/feed.xml" title="Max Design articles">
<style>
.footnote-target:focus,
.footnote-target:target,
.ref-target:focus,
.ref-target:target {
  outline: 2px dotted black;
  animation: fade 3s forwards;
}

@keyframes fade {
  0% {
    background-color: #ffff00;
    outline-color: black;
  }
  100% {
    background-color: transparent;
    outline-color: transparent;
  }
}

</style>
</head>
<body>
  <header>
    maxdesign.com.au
  </header>
  <nav aria-label="Site">
    <ul>
      <li><a href="../index.html">Home</a></li>
      <li><a href="../about/index.html">About</a></li>
      <li><a href="../resources/index.html">Resources</a></li>
      <li><a href="../talks/index.html">Presentations</a></li>
      <li><a href="../articles/index.html" class="current">Articles</a></li>
    </ul>
  </nav>
  <div class="banner-inner">
    <div class="banner-content">
      <h1>Understanding aria-live timing: a two-layer model</h1>    
    </div>
  </div>  
  <main>

<p class="metadetails">Published: <time datetime="2025-12-02">2 December 2025</time></p>

<p>Did you know that there are two completely separate systems that determine when live regions are spoken? They are:</p>

<ul>
  <li>Screen reader speech queue (assistive technology layer)</li>
  <li>System-driven scheduling (browser / event loop level)</li>
</ul>

<p><b>Assertive</b> announcements <sup class="ref-target" id="ref-assertiveannouncements"><a href="#assertiveannouncements">1</a></sup> are controlled almost entirely by the screen reader.</p>

<p><b>Polite</b> announcements <sup class="ref-target" id="ref-politeannouncements"><a href="#politeannouncements">2</a></sup> depend on both systems, which is why their timing can vary so much in practice.</p>

<p>Let&rsquo;s look at these two systems in detail.</p>

<hr>


<!--  –––––––––––––––––––––––––
******  SECTION ******
––––––––––––––––––––––––––  -->


<h2>1. Screen reader speech queue (assistive technology layer)</h2>

<p>Screen readers manage their spoken output using an internal speech queue.</p>

<p>An item spoken by the screen reader is called an <i>utterance</i>. This is a single self-contained chunk of speech.</p>

<p>The queue contains:</p>

<ul>
  <li>Utterances from user navigation (<em>&ldquo;Heading level 2 ...&rdquo;</em>)</li>
  <li>Speech produced by reading text (<em>&ldquo;The quick brown fox ...&rdquo;</em>)</li>
  <li>Dynamic announcements (ARIA live region updates)</li>
  <li>Semantic hints (<em>&ldquo;button&rdquo;</em>, <em>&ldquo;selected&rdquo;</em>, <em>&ldquo;expanded&rdquo;</em>)</li>
</ul>

<p>This queue is generally processed FIFO (first in, first out) unless specific rules override it.</p>

<h3>Assertive announcements:</h3>

<ul>
  <li>Immediately flush active and pending utterances.</li>
  <li>Interrupt whatever is being spoken.</li>
  <li>Insert the assertive utterance at the front.</li>
  <li>Speak it next.</li>
</ul>

<p><b>Assertive</b> always wins because &ldquo;interrupt behaviour&rdquo; is part of the queue layer.</p>

<h3>Polite announcements:</h3>

<ul>
  <li>Are added to the end of the speech queue.</li>
  <li>Never interrupt the user.</li>
  <li>Only play when the queue becomes empty.</li>
  <li>Wait behind navigation, reading, search/cursor operations, etc.</li>
</ul>

<p>This means user activity always delays <b>polite</b> announcements. But screen readers do not wait for sentences or paragraphs. They only wait until their queue empties.</p>

<p>This explains the first half of why <b>polite</b> announcements vary.</p>

<hr>


<!--  –––––––––––––––––––––––––
******  SECTION ******
––––––––––––––––––––––––––  -->


<h2>2. System-Driven Scheduling (Browser / Event Loop Layer)</h2>

<p>Before a screen reader can speak anything, the browser must:</p>

<ul>
  <li>Detect the DOM mutation <sup class="ref-target" id="ref-dommutation"><a href="#dommutation">3</a></sup>.</li>
  <li>Update the accessibility tree.</li>
  <li>Decide when to fire an AX event <sup class="ref-target" id="ref-axevent"><a href="#axevent">4</a></sup>.</li>
  <li>Deliver that event to the OS accessibility API.</li>
  <li>Which then delivers it to the screen reader.</li>
</ul>

<p>This pipeline runs on the browser’s internal scheduling systems, which include (but are not limited to) the JavaScript event loop, microtasks, rendering pipeline timing, and asynchronous accessibility tree updates.</p>

<p>The event loop management includes:</p>

<ul>
  <li>The call stack <sup class="ref-target" id="ref-callstack"><a href="#callstack">5</a></sup>.</li>
  <li>The microtask queue <sup class="ref-target" id="ref-microtaskqueue"><a href="#microtaskqueue">6</a></sup>.</li>
  <li>Rendering pipeline (layout, paint, compositing).</li>
  <li>Timers.</li>
  <li>Input events.</li>
  <li>Animation frames.</li>
  <li>AX tree updates.</li>
</ul>

<p>This is the other half of live region timing.</p>

<p>Let&rsquo;s explore how <b>assertive</b> and <b>polite</b> differ at the scheduling layer.</p>

<h3>Assertive Timing</h3>

<p><b>Assertive</b> live region AX events are scheduled as soon as possible:</p>

<ul>
  <li>JavaScript-driven DOM mutation <sup class="ref-target" id="ref-javascriptdrivenmutation"><a href="#javascriptdrivenmutation">7</a></sup>.</li>
  <li>Call stack becomes empty.</li>
  <li>Microtasks drain <sup class="ref-target" id="ref-microtasksdrain"><a href="#microtasksdrain">8</a></sup>.</li>
  <li><b>ASSERTIVE AX EVENT FIRES ←</b></li>
  <li>Rendering may happen after this.</li>
  <li>Task queue work happens later.</li>
</ul>

<p>Why <b>assertive</b> is fast:</p>

<ul>
  <li>It fires after the current JavaScript job, when the microtask queue empties.</li>
  <li>It occurs before rendering changes.</li>
  <li>It is never delayed by a render cycle.</li>
  <li>It is not postponed by animations, layouts, or timers.</li>
</ul>

<p>The only thing that can delay <b>assertive</b> is potential microtask starvation. This happens when microtasks keep running forever, so the browser never gets a chance to move on to the next task.</p>

<p>This explains why <b>assertive</b> is reliable and immediate in practice.</p>

<h3>Polite Timing</h3>

<p><b>Polite</b> live region AX events are intentionally delayed:</p>

<ul>
  <li>JavaScript-driven DOM mutation.</li>
  <li>Call stack becomes empty.</li>
  <li>Microtasks drain.</li>
  <li>Wait for the next rendering opportunity after style/layout have settled.</li>
  <li><b>POLITE AX EVENT FIRES ←</b></li>
  <li>Task queue work happens later.</li>
</ul>

<p><b>Polite</b> must wait for a future render tick, and a “stable render state” can be delayed by:</p>

<ul>
  <li>active layouts</li>
  <li>reflows</li>
  <li>animations</li>
  <li>transitions</li>
  <li>scrolling</li>
  <li>microtask storms</li>
  <li>React/Vue batching</li>
  <li>timers</li>
  <li>heavy CPU load</li>
  <li>compositor operations</li>
  <li>pending task queue events</li>
</ul>

<p>These delays affect the scheduling of the announcement, before the screen reader ever receives it.</p>

<hr>


<!--  –––––––––––––––––––––––––
******  SECTION ******
––––––––––––––––––––––––––  -->


<h2>Putting Both Systems Together</h2>

<p>This unified pipeline shows exactly where delays occur:</p>

<pre><code>DOM Mutation
        ↓
  Browser Scheduling Layer
  (when to fire AX events)
        ↓
  AX Event Fired
        ↓
  Screen Reader Speech Queue
  (what gets spoken & in what order)
        ↓
  TTS Utterance Output</code></pre>

<p><b>Assertive</b> announcements:</p>

<ul>
  <li>Fast scheduling (after microtasks).</li>
  <li>Immediate queue flush.</li>
  <li>Spoken right away.</li>
</ul>

<p><b>Polite</b> announcements:</p>

<ul>
  <li>Delayed scheduling (after future render).</li>
  <li>Added to end of queue.</li>
  <li>Spoken only after all user-driven utterances finish.</li>
</ul>

<p>This is why <b>polite</b> announcements vary so much more than assertive ones.</p>

<hr>


<!--  –––––––––––––––––––––––––
******  SECTION ******
––––––––––––––––––––––––––  -->


<h2>Caveats and nuances</h2>

<ul>
  <li><b>AX event timing may vary</b>: Browsers may batch, coalesce or optimise accessibility events internally, so timing may not always follow a simple assertive/polite pattern.</li>
  <li><b>Screen reader behaviour differs</b>: Each assistive technology has its own rules for interrupting, queuing and speaking updates, and these behaviours can vary across versions and operating systems.</li>
  <li><b>Rendering stability is implementation-dependent</b>: What counts as a “stable render state” differs between browser engines, especially during animations, transitions, layout changes or heavy CPU activity.</li>
  <li><b>Heavy JavaScript can delay announcements</b>: Long tasks, microtask storms or blocked main-thread execution can postpone both assertive and polite updates.</li>
  <li><b>Results may vary</b>: Timing differs across Blink, WebKit and Gecko due to differences in layout, rendering and accessibility pipelines.</li>
  <li><b>Always test across AT and browser combinations</b>: Real-world timing depends on the interaction between JavaScript, browser scheduling, OS accessibility APIs and the screen reader&rsquo;s own queue.</li>
</ul>

<hr>


<div class="further-reading">
  <h2>Related articles</h2>

  <p>
    <a href="https://www.maxdesign.com.au/articles/index.html"><b>What is an AXEvent?</b></a><br>Detailed explanation of AXevents.
  </p>

  <p>
    <a href="https://www.maxdesign.com.au/articles/accordion-button.html"><b>What really happens when a user clicks an accordion button?</b></a><br>
    A more detailed explanation of an event.
  </p>

  <p>
    <a href="https://www.maxdesign.com.au/articles/dom-mutations.html"><b>What are DOM mutations?</b></a><br>
    DOM mutations are any changes to the accessibility tree.
  </p>

  <p>
    <a href="https://www.maxdesign.com.au/articles/end-to-end-event-architecture.html"><b>End-to-end browser and accessibility event architecture</b></a><br>
    A full explanation of how browsers and assistive technologies communicate.
  </p>
</div>

<hr>


<!--  –––––––––––––––––––––––––
******  SECTION ******
––––––––––––––––––––––––––  -->


<h2>Footnotes</h2>
<ul>  
  <li>
    <span id="assertiveannouncements" tabindex="-1" class="footnote-target">[1]</span>
    <b>Assertive announcements</b>: Announcements made using <code>aria-live="assertive"</code>.
    [<a href="#ref-assertiveannouncements" class="back">Back</a>]
  </li>

  <li>
    <span id="politeannouncements" tabindex="-1" class="footnote-target">[2]</span>
    <b>Polite announcements</b>: Announcements made using <code>aria-live="polite"</code>.
    [<a href="#ref-politeannouncements" class="back">Back</a>]
  </li>

  <li>
    <span id="dommutation" tabindex="-1" class="footnote-target">[3]</span>
    <b>DOM mutation</b>: Any change to the DOM — whether triggered by JavaScript, user interaction, or browser behaviour — such as adding, removing, or updating elements or attributes.
    [<a href="#ref-dommutation" class="back">Back</a>]
  </li>

  <li>
    <span id="axevent" tabindex="-1" class="footnote-target">[4]</span>
    <b>AX event</b>: An accessibility event fired by the browser when something meaningful changes in the accessibility tree, such as focus, name, value, or state changes.
    [<a href="#ref-axevent" class="back">Back</a>]
  </li>

  <li>
    <span id="callstack" tabindex="-1" class="footnote-target">[5]</span>
    <b>The call stack</b>: A temporary structure the JavaScript engine builds while running code, showing which functions are currently being executed. It grows as functions call other functions and shrinks as they return.
    [<a href="#ref-callstack" class="back">Back</a>]
  </li>

  <li>
    <span id="microtaskqueue" tabindex="-1" class="footnote-target">[6]</span>
    <b>Microtask queue</b>: A queue of small, high-priority callbacks (e.g. Promise handlers, MutationObserver notifications) that must run immediately after the current JavaScript task finishes and before rendering or the next task begins.
    [<a href="#ref-microtaskqueue" class="back">Back</a>]
  </li>

  <li>
    <span id="javascriptdrivenmutation" tabindex="-1" class="footnote-target">[7]</span>
    <b>JavaScript-driven DOM mutation</b>: A DOM change caused directly by JavaScript code, such as creating elements, updating attributes, or altering text content.
    [<a href="#ref-javascriptdrivenmutation" class="back">Back</a>]
  </li>

  <li>
    <span id="microtasksdrain" tabindex="-1" class="footnote-target">[8]</span>
    <b>Microtasks drain</b>: The point in the event loop when all queued microtasks must be executed to completion before the browser is allowed to render or pick up the next task.
    [<a href="#ref-microtasksdrain" class="back">Back</a>]
  </li>
</ul>

<script>
// Select ALL footnote links inside <sup>
document.querySelectorAll('sup a[href^="#"]').forEach(link => {
  link.addEventListener('click', e => {
    // Extract ID by stripping the "#" from the href
    const id = link.getAttribute('href').slice(1);

    // Find the matching element in the document
    const target = document.getElementById(id);

    if (target) {
      // Ensure the target can receive programmatic focus
      target.setAttribute('tabindex', '-1');

      // Move focus there
      target.focus();
    }
  });
});

</script>

  </main>
  <footer>
    <ul>
      <li><a href="/sitemap.html">Sitemap</a></li>
      <li><a href="/feed.xml">Feed</a></li>
      <li><a href="/contact-us/index.html">Contact</a></li>
      <li><a href="https://github.com/russmaxdesign" target="_blank">Github</a></li>
      <li><a href="https://www.linkedin.com/in/russweakley/" target="_blank">Linkedin</a></li>
    </ul>
    <p>Copyright &copy; Max Design 2025</p>
  </footer>
</body>
</html>
